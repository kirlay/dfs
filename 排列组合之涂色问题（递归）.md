[TOC]

# 排列组合

## 涂色问题

### 3473: 量子计算

**题目描述**
做完基因锁手术后，小Ｘ又被机器狗带回到了会客舱，外星首领请小Ｘ喝了杯龙冠龙井，说道：“此茶乃 G20 峰会专用，对你的术后恢复大有裨益，在送你回地球之前，你可以再问一个问题。”小Ｘ问道：“人类这么多年都未能破译基因密码，你们是如何做到的呢？”外星首领答道：“这全靠我们的科学家发明的128 位量子计算机，它的计算速度大约是 2 的 128 次方，而地球上最快的光电计算机目前最快能算到 2 的32 次方左右。”小Ｘ梦醒之后上网查阅了一下有关量子计算机的最新发展状况，发现米国已经在研制 50 位的量子计算机了，联想到最近发生的中兴事件，小Ｘ心想一旦量子计算技术再受制于人，那后果就十分严重了，于是小Ｘ计划研制 64 位的量子计算机，他觉得这个任务有些艰巨，需要找几位天资聪颖且志同道合的小伙伴来帮助自己，于是就想到了这次的程序设计小能手比赛，小Ｘ出了下面这个题目来考考小朋友
们，通过的同学将有机会跟小Ｘ一起研制量子计算机哦！一个圆被均分成了 n 个区域，现有 m 种可供选择的颜色给图中的区域涂色，每一个区域只能涂一种颜色，且相邻的区域要涂不同的颜色，问有多少种不同的涂色方式？由于结果很大，你只要输出结果除以10000007 的余数的值。
以下是 n=5 的时候的圆被分成的样子。


**输入**
输入数据仅有一行包含两个用空格隔开的正整数 n,m，即圆被分成了 n 个区域，有 m 种可供选择的颜色。

**输出**
输出数据仅有一行包含一个整数，表示不同的涂色方式，请输出对 10000007 求余后的值。

**样例输入 **
5 3
**样例输出** 
30
提示[-]
10%的数据 m=2
40%的数据 m<=3，n<=15
70%的数据 m<=5，n<=100
100%的数据 m<=100，n<=1000

**来源**
常州市2018“信息与未来”夏令营选拔赛

### 难度
4星

### 思路

> 当圆只有1个区域的时候，答案是m种颜色
> 当圆有2个区域，答案是m*(m-1)中颜色
> 当圆有3个或者3个以上区域的时候，思路是这样的：
>
> > 第一个格子有m种颜色的可能性
> > 第2个格子有m-1种颜色的可能性
> > 第3个格子有m-1种颜色的可能性
> > 依次类推
> > 这样是有不符合的情况，也就是第1个和最后一个的颜色一样
> > > 这时我们可以把这样的情况，想成只有一个的区域，就就是圆被分成了n-1个区域
> > > 因此上面的“乘法原理”取得的结果，还要减去f（n-1）

### 容易写错的地方，值得思考的地方
1. **会出现负数的情况**
```c++
ans=(ans- f(x-1)+10000007)%10000007;
```
2. **递归条件，这里要把x==2放入，本来会出问题，这是特殊的**
```c++
	if(x==1) return m;
	if(x==2) return m*(m-1);
```
3. **为什么不需要进行记忆化优化?**
	可以进行手动模拟一次

### 递归代码实现

方法1

```c++
#include<iostream>
using namespace std;
long long mm[105],n,m;
long long f(long long x){
	if(x==1) return m;
	long long ans=m;
	for(long long i=2;i<=x;i++){
		ans *= (m-1);
		ans %=  10000007;
	}
	if(x>2)
		ans=(ans- f(x-1)+10000007)%10000007;
	return ans;
}
int main(){
	cin>>n>>m;
	cout<<f(n);
	return 0;
}
```

方法2 ：

```c++
#include<iostream>
using namespace std;
long long mm[105],n,m;
long long f(long long x){
	if(x==1) return m;
	if(x==2) return m*(m-1);
	long long ans=m;
	for(long long i=2;i<=x;i++){
		ans *= (m-1);
		ans %=  10000007;
	}
	ans=(ans- f(x-1)+10000007)%10000007;
	return ans;
}
int main(){
	cin>>n>>m;
	cout<<f(n);
	return 0;
}
```



